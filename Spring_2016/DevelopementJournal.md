##Developement Journal
#Garrett Wells

##dateofcompletion
Entry explaining what you have been done that week in working on the project. Each journal entry must be at least 150 words written with proper grammar and complete sentences. Your grade for this project will be largely based on this journal, so don't slack on it. Make sure it's stored in a markdown text file and is included in your GitHub repository.

##2/5/16
This week I received the raspberry pi along with all of the parts that I need to begin learning Python and setting up the raspberry pi. At the beginning of the week I watched several tutorials on how to navigate the Linux file system. I took notes on the things I learned (CommandsForLinux.md) and also researched the hardware I would need in order to use the raspberry pi. The pi 2 B+ arrived on Wednesday and I was able to begin work on it immediately. I was working on it from 10:45 am to 4:30pm. I read the step by step setup instructions that I found on Adafruit’s website and was able to first set up the automatic Wi-Fi connection on start up. Then I began finding a way to allow the pi to interface with my laptop so that I would be able to use my laptop's screen in collusion with the raspberry pi's graphics. To accomplish this I had to do two things. Set up a SSH terminal(Secure Shell), and then set up a VNC(Virtual Network Connection).    

##2/12/16
I learned that the raspberry pi B+ is integrated in such a way that Python is the easiest language to program it in. As a result I created a code academy account and have begun learning the Python syntax rules. In addition to learning the extreme basics of Python I began learning about how to create circuits that feature LED lights which I can then light up by running a program in Python. For some unknown reason I have not been successful in getting power to my circuit from the pi but, as a positive, I was able to write a Python program that ran with limited success. It out putted instructions for how to run the program, but did little else, namely not causing the LED's to light up. I have tried completeing one of the basic recommended projects provide by adafruit but with no success. My failure may have been a result of my not activating the SPI interface for the pi. The SPI(Serial Peripheral Interface) provides short range communications between the pi and other connected devices such as my circuit, so perhaps its state of non-activation was the reason my attempts at running a program failed.

##2/19/16
This week I successfully installed the SPI interface on my pi's operating system and also proceeded to continue working on learning python. I learned the syntax for conditionals and began creating a python version of the pig latin translator that we created in comp sci. Midway through the week I began having problems accessing the pi via SSH. I decided to try reinstalling the operating system and starting over again from scratch. However, I began experiencing problems, namely I could not boot from the SDC. I watched all of the tutorials and posted for help on a couple of forums and was eventually successful in reformatting the SDC and installing the operating system. However, when I tried to boot from the SDC again I ran into a string of boot errors. One of the errors mentioned was that the installed operating system was too big for the SDC. This has led me to try to find a smaller OS and install that. This whole process has been slow and extremely frustrating, especially since it has taken hours of debugging to even get on the right track.

##2/26/16
This week I reinstalled the operating system on the pi's SDHC and then I continued to learn python. I primarily learned how to use the funtions in python. Then I began making a pig latin translator in python to further refine my new found skills. By learning how to translate from pig latin into English I learned how to use the string functions supplied by python. I also learned that python is named after Monty Python. Python's implementer, Guido van Rossum, was reading the scripts for Monty Python's Circus at the same time he was working on Python and decided to name his language after the comedy group. Python's syntax is much looser and less specific than Java, something that makes it easy to learn but at the same time harder to read. I personally like Java more than python and may consider doing my project in C instead of Python if I can figure out the GPIO support libraries in C. I will also need to reinstall all of the SPI and I2C libraries on the pi so that I will be able to run python programs and breakout boards on the pi. After reinstalling the operating system I set about reconfiguring the wifi connections and gpio libraries installed on the pi. This went fairly quickly and I was able to move on to working on creating a circuit and trying to program it. I sucessfully ran the program but I have fatal flaws in the area of my circuit.

##3/4/16
 I worked on learning more python and was able to hook up the GPS and begin receiving data from it via the terminal. However, I could not get the GPS to get a “fix”, in other words it was unable to figure out where it was. I may need to get an antenna to go on it but hopefully not. I found out that there is a program that I can install which will automatically read the data from the GPS and translate it into coordinates that are easier to understand. I will eventually make my own version of this, but better. I do  not know at this point whether I will be able to finish by the end of the year and it seems like the mountain I have picked for my stroll will become the steepest ascent of my sophomore year. Oh, well. My next step is to find a way to read the inputs from the GPS as they come in and output them using my own program that I will write in python. Once I have that I will have accomplished a major first step. It will be difficult though... Mean while I still have not figured out how to get my circuit to work and I will need to seek the advice of a professional or at the least that of an experienced amateur. From my own tests I have concluded that the LED's are defunct.

##3/13/16
This week I worked on setting up the wireless VNC connection with my raspberry pi so that I will be able to program it when it has the GPS hat on it without needing to use the serial ports for a TTL to USB connection. Then I began reading a book by Simon Monk about how to program the raspberry pi. I learned a great deal about how the pi interacts with Python 2 as well as Python 3. His book contained several sections that I found particularly interesting. First, he wrote about how to use Python to read and write data to files, something that I may use in my data collection from the pi. Second, Monk wrote about how to implement simple GUI's. I would like to not only learn how to record the data from the raspberry pi but I would like to learn how to create a GUI that will process the information and present it in a user friendly manner. The tough part will be breaking down the individual tasks into problems that I will be able to tackle with my scanty programming knowledge.

##3/18/16
This week I installed python and began working on how to make my GUI that I will be using for my GPS. It will be very simplistic, and will only supply a few functions that, while basic, should make using the GPS much more efficient and helpful. I still need to figure out how to access the data from the GPS and convert that into a readable form. I may be able to find some software to do it for me but I am not confident that that will end up working out for me. I also learned how to write modules that I can import and use specifically for my project. All I need to do is write a separate module and then import it. I need to learn more about how the file access works and how to write and read files that my program will need to handle. 

##3/25/16
This week I did a large number of things. First, I fixed the connection problem that my GPS was having when it was hooked up to the pi. I would enter the commands to start the GPS data stream and instead of NMEA sentences I would not get anything back. I tried restarting the process a couple of times but in the end was unable to figure out the answer on my own. I posted a question on the vendor's  website and I was told that the RXD and TXD pins were most likely improperly connected to the pi. This was impossible that the pins were not connected to the pi but I tried reconnecting the GPS any way and I found that doing so solved my problem. Now, the suggested solution was still incorrect, but I   did have a faulty connection some where in my system. Anyway, moving on, I then began writing the code to parse the NMEA sentences from the GPS. This presented several problems. First, the GPS sends its output to the command line of the pi. As a result I needed a way to save the NMEA sentences so that my own program could parse through them and return an output.  Second, the pi receives so much data from the GPS that if I was successful in writing the data to a file the file would soon become so large that it would be too unwieldy, and potentially too big for the pi to handle. In short I needed a way to control the flow of data to the file that I am writing. Eventually I found several solutions. For my first problem I found that Python has a module called subprocess which allows the user to run command line arguments while remaining in a python script. This module also allows the user to capture the output of the command that was just run in the script. For my second problem I actually found a person on Stack Overflow who had the same problem and had solved it so I was able to copy his code, making up for my own lack of knowledge.

##3/1/16
I learned that if I want to make the GPS so that it can continue to run while the pi is not connected to a power source, I need to supply the GPS with its own independent power source. Luckily the GPS has a disk battery clip, so that problem is easily solved and I have ordered the batteries which should arrive by the fourth of this month. By adding the battery the GPS hat will be able to search continuously for satelites and obtain a fix of its position even if the raspberry pi is not able to supply the power needed to support that type of continuous search. I also need to begin working on parsing the NMEA sentences, and while I have written some code to begin the data collection and management, I have not been able to test it or begin writing the code that will handle the data parsing, sadly.

##4/8/16
This week I began writing the code for the GPS data handling modules. I learned that I can create my own modules and import them into a separate module that will handle their implementation. I currently have three different modules. One is to start the application and provide a minimalistic user interface. This module imports the two other modules that I use for actually collecting and parsing through the data from the GPS. This first module is called the Ultimate_GPS_Tracker. The second module, the DataManager.py starts the sub-process that communicates between the GPS and the PI, writes the data to a file called GPS_Data.txt. The third module is called Parser.py and is in control of parsing through the data collected in GPS_Data.txt and relaying that data to whatever type of user interface I use. To make a product that I would want to use myself I will need to make a system of implementation and expedite fast operation. I want to provide a live updating of the GPS data and communication to the user but how to do that is currently unsolved. I have another goal for my application. I want the application to be so easy to use that any one can use it, and be able to perform all actions that the application is capable of providing with only a few basic commands.

##4/15/16
I added a battery to supplement the power of the GPS so that it would have continuous time tracking. As an added benefit I found that the GPS now gets a fix reliably from inside my house, something that it is not supposed to be able to do, and it can obtain a fix in under a minute. Virtually on start-up, whereas it used to not be able to obtain a fix at all or at best after nearly thirty minutes of searching for a signal. After getting a signal I was able to start working on testing the program that I have written for the sentence parsing. It is far from completed. Much of the parsing returns incorrect values and does not present the information in a readable format. However, I am not sure if my current method of running the program through the command terminal is the best way to present the information in a readable format. As a result I have begun working on implementing a GUI that will hopefully allow the  user to not need to use the command terminal. Right now the GUI has no way of out putting the information collected by the GPS. I am also hoping to make it possible to tell the program to either save the data to a file or just output the information.

##4/22/16
I began testing my code and polishing the user interface. I learned how to use the command prompt in windows, namely how to change the system path variable so that I would be able to run my python programs directly from command prompt. Then I also installed pip in python for the raspberry pi which took a long time and many tries before I found a version of pip that used syntax that was compatible with python 3.2.  Afterward , I installed clint, a command line UI module for python that allows me to add colored text and other nice features to the program. Before I installed clint for python 3.2 I was trying to run the program which I had developed in 3.4 on 2.7 which resulted in multiple syntax and file parsing errors. These errors forced me to install pip for 3.2 so that I could then install clint in 3.2. After implementing these changes I was able to run my program successfully. Next I will begin adding a more application like aspect to my program.

##4/29/16
I am still playing around with Clint, the command line interface that I had implemented into my program and trying to figure out how to use it. The big problem is that I currently cannot get any documentation on it which means that I can not implement fancy stuff like a self updating spreadsheet of the GPS data that is running at a live time schedule. This bugs me as other competitors in the GPS app field have this capability but I do not. I am not able to put much work into this as I am leaving town on Wednesday and will not have access to my code until Sunday and even then I will be studying for the AP tests and trying to rest up. Any way, the point is that I need to improve the polish of my program and the user friendliness so that customers will want to use it just like me. That means that the command line interface, if it is not fancy in the ways listed above, must be at least easy to move through and effective in what it does. Furthermore, the program must be more versatile, it must excel in many areas that competitors do not.

##5/6/16
Well, this week I did less on my project because I was busy with AP test review and other tedious things. However, I did begin exploring a new command line interface that may be able to replace the current one that I have implemented. The reason this would be a good thing is that the current module has no documentation which means that I am unable to figure out how to use it effectively for my particular application. The new module is called Cliff and although it does not look very promising I am still researching it. Meanwhile, I have been brainstorming ways to make my existing program useful and I have realized that in most instances where a GPS is most useful it is impractical to have it hooked up to a computer monitor or touchscreen while the user is walking around just so that they can see where they are. Therefore, I have decided to make it so that the GPS data log will start immediately  when the raspberry pi receives power and begins to boot up. This will vastly increase the range of customers I will be able to attract as well as the applications that it can be used for. I am also thinking of ways that I can package it to self install on other machines with as little user interaction as possible. That way even inexperienced user will be able to install and run it. 

##5/13/16
I have begun adding the code that will allow the users to configure the program that runs on the start up of the pi. Specifically I have added a time management function that allows the user to set a time limit on the data collection process so that the user can take a trip and only need to plug in the pi while they are walking around and record their movements for an unlimited amount of time. In addition to this they can record a set number of data sentences which although it may not be that helpful in general, it will be useful in fringe cases. Furthermore, I have integrated my settings configuration into the overall program command structure so that users can change things with a single command and can choose between timed and measured data collection. I have yet to test this on the pi and that will be the next step in the process, in the long journey that this project has become.

##5/20/16
This whole week I have been testing and polishing my code for the GPS. I started out the week trying to set up a module that would allow the user to configure the settings text file that will control the data recording process that is activated on startup. I had already written the code but when I tried to run the code it immediately crashed because there were many typos and other mistakes that prevented the code from running. Eventually though I was able to get the settings file configuration code working which set me up to work on the actual script that will run when the pi starts. I struggled with this for several days trying to find a way to effectively assess the points of failure that I was struggling with. This was extremely frustrating since although I followed the instructions that I was able to find online I kept running into problems which although I knew they existed, I had no way of testing them to see what was actually happening since if a problem occured the pi would kill the script, leaving no record of what happened. Finally, I found the actual source files and ran them individually to test them. Through doing this I found and corrected the problems and presto! It worked! And I learned a lot!